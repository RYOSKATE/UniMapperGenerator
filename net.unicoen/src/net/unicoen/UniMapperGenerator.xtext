grammar net.unicoen.UniMapperGenerator with org.eclipse.xtext.common.Terminals

generate uniMapperGenerator "http://www.unicoen.net/UniMapperGenerator"

/** Grammar */
Grammar
  :
    type=GrammarType? 'grammar' name=Id_ ';'
    prequels+=PrequelConstruct*
    rules+=Rule*
    modes+=Mode*
  ;

enum GrammarType
  :
     DEFAULT='default_hack_'
  |  LEXER='lexer'
  |  PARSER='parser'
  |  TREE='tree'
  ;

PrequelConstruct
        : 
      Options

    | Imports

    | Tokens

    | GrammarAction
    ;

/** Options */
Options
  :
    {Options}
    keyword=OPTIONS_SPEC (options+=Option ';')* '}'
  ;

Option
  :
    TokenVocab
  | name=Id_ '=' value=OptionValue
  ;

TokenVocab
  :
    name=TOKEN_VOCAB '=' importURI=[Grammar|Id_]
  ;

OptionValue
  :
    QualifiedOption
  | StringOption
  | ActionOption
  | IntOption
  ;

QualifiedOption
  :
    value=QualifiedId
  ;

StringOption
  :
    value=STRING
  ;

ActionOption
  :
    value=ACTION
  ;

IntOption
  :
    value=INT
  ;


/** Imports */
Imports:
  keyword='import' imports+=Import (',' imports+=Import)* ';'
  ;

Import
  :
    alias=Id_ '=' importURI=[Grammar|Id_]
  | importURI=[Grammar|Id_]
  ;

/** Tokens */
Tokens
  :
    V4Tokens
  | EmptyTokens
  | V3Tokens
  ;

V4Tokens
  :
    keyword=TOKENS_SPEC tokens+=V4Token (',' tokens+=V4Token)* '}'
  ;

V4Token
  :
    name=Id_
  ;

EmptyTokens
  :
    {EmptyTokens} keyword=TOKENS_SPEC '}'
  ;

V3Tokens
  :
    keyword=TOKENS_SPEC tokens+=V3Token+ '}'
  ;

V3Token
  :
    id=Id_ ('=' value=STRING)? ';'
  ;

/** Grammar Actions */
GrammarAction
  :
    atSymbol='@' (scope=ActionScope colonSymbol='::')? name=Id_ action=ACTION
  ;

ActionScope
  :
    'parser'
  | 'lexer'
  | 'tree'
  | Id_
  ;

Mode
  :
    'mode' id=Id_ ';'
    rules+=LexerRule*
  ;

/** Rules */
Rule
  :
    ParserRule
  | LexerRule
  ;

/** Parser Rules */
ParserRule
  :
    name=RULE_REF

    args=ARG_OR_CHARSET?

    return=Return?

    throws=Exceptions?

    locals=LocalVars?

    prequels+=RulePrequel*

    COLON

    body=RuleBlock

    caught=ExceptionGroup
    semicolonSymbol=';'
  ;

ExceptionGroup
    :
      {ExceptionGroup} handlers+=ExceptionHandler* finally=FinallyClause?
    ;

ExceptionHandler
  :
    'catch' 
    exception=ARG_OR_CHARSET 
    body=ACTION
  ;

FinallyClause
  : 'finally' body=ACTION
  ;

Return
  :
    'returns' body=ARG_OR_CHARSET
  ;

Exceptions
  :
    'throws' exceptions+=QualifiedId (',' exceptions+=QualifiedId)*
  ;

LocalVars
  :
    'locals' body=ARG_OR_CHARSET
  ;

RulePrequel
  :
    Options
  | RuleAction
  ;

RuleAction
  :
    atSymbol='@' name=Id_ body=ACTION
  ;

RuleBlock
  :
    body=RuleAltList
  ;

RuleAltList
  :
    alternatives+=LabeledAlt ('|' alternatives+=LabeledAlt)*
  ;

LabeledAlt
  :
    body=Alternative (poundSymbol='#' label=Id_)?
  ;

Alternative
  :
    {Alternative}
    options=ElementOptions?
    elements+=Element*
  ;

Element
  :
    body=LabeledElement operator=EbnfSuffix?
  | body=Atom operator=EbnfSuffix?
  | body=Ebnf
  | body=ActionElement
  ;


Ebnf
    : body=Block
      operator=EbnfSuffix?
    ;

ActionElement
  :
    body=ACTION options=ElementOptions?
  ;

LabeledElement
  :
    name=Id_ ('=' | '+=')
      (
        body=Atom
      | body=Block
      )
  ;

EbnfSuffix
  :
    operator='?' nongreedy='?'?
  | operator='*' nongreedy='?'?
  | operator='+' nongreedy='?'?
  ;

Block
  :
    '('
        ( options=Options? actions+=RuleAction* COLON )?
        body=AltList
    ')'
  ;

AltList
  :
    alternatives+=Alternative ('|' alternatives+=Alternative)*
  ;

Atom
  :
    body=Range  // Range x..y - only valid in lexers
  | body=Terminal
  | body=RuleRef
  | body=NotSet
  | body=Wildcard
  ;

RuleRef
  :
    reference=[ParserRule|RULE_REF] 
    //args=ARG_OR_CHARSET? 
    options=ElementOptions?
  ;

ElementOptions
    :
      {ElementOptions} begin='<' (options+=ElementOption (',' options+=ElementOption)*)? end='>'
    ;

Range
  :
    from=STRING '..' to=STRING
  ;

Terminal
  :
    reference=[TokenRef|TOKEN_REF] options=ElementOptions?
  | literal=STRING options=ElementOptions?
  ;

TokenRef
  :
    V3Token
  | V4Token
  | LexerRule
  ;

NotSet
  : '~' body=SetElement
  | '~' body=BlockSet
  ;

BlockSet
    :
      '(' elements+=SetElement ('|' elements+=SetElement)* ')'
    ;

SetElement
  :
    tokenRef=TOKEN_REF
  | stringLiteral=STRING
  | range=Range
  | charSet=ARG_OR_CHARSET
  ;

Wildcard
  :
    dot='.' options=ElementOptions?
  ;

ElementOption
    : 
      qualifiedId=QualifiedId
    | id=Id_ assign='=' value=OptionValue
    ;

/** Lexer Rule */
LexerRule
  :
    ^fragment?='fragment'?
    name=TOKEN_REF COLON body=LexerRuleBlock semicolonSymbol=';'
  ;

LexerRuleBlock
  :
    body=LexerAltList
  ;

LexerAltList
  :
    alternatives+=LexerAlt ('|' alternatives+=LexerAlt)*
  ;

LexerAlt
  :
    body=LexerElements commands=LexerCommands?
  ;

LexerElements
  :
    {LexerElements}
    elements+=LexerElement*
  ;

LexerElement
  :
    body=LabeledLexerElement operator=EbnfSuffix?
  | body=LexerAtom operator=EbnfSuffix?
  | body=LexerBlock operator=EbnfSuffix?
  | body=ActionElement
  ;

LabeledLexerElement
  :
    label=Id_ ('='|'+=')
    (
      body=LexerAtom
    | body=LexerBlock
    )
  ;

LexerAtom
  :
    body=Range  // Range x..y - only valid in lexers
  | body=Terminal
  | body=RuleRef
  | body=NotSet
  | body=Wildcard
  | body=LexerCharSet
  ;

LexerCharSet
  :
    body=ARG_OR_CHARSET
  ;

LexerBlock
  :
    '('
        ( options=Options COLON )?
        body=LexerAltList
    ')'
    ;

LexerCommands
  :
    keyword=RARROW commands+=LexerCommand (',' commands+=LexerCommand)*
  ;

LexerCommand
  :
    name=LexerCommandName '(' args=LexerCommandExpr ')'
  | name=LexerCommandName
  ;

LexerCommandName
  :
    'mode'
  | Id_
  ;

LexerCommandExpr
  :
    ref=[LexerCommandArg|Id_]
  | value=INT
  ;

LexerCommandArg
  :
    Mode
  | LexerRule
  | V3Token
  | V4Token
  ;

/** ID */
QualifiedId
  :
    name+=Id_ ('.' name+=Id_)*
  ;

Id_
  :
  TOKEN_REF
  | RULE_REF
  ;

/** tokenVocab */
terminal
TOKEN_VOCAB: 'tokenVocab';

/** COLON */
terminal
COLON: ':';

/** -> */
terminal
RARROW: '->';

/** Options */
terminal
OPTIONS_SPEC
  :
  'options' WSNLCHARS* '{'
  ;

/** Tokens */
terminal
TOKENS_SPEC
  :
  'tokens' WSNLCHARS* '{'
  ;

/** IDS */
terminal
RULE_REF
  :
  'a'..'z'
  NAME_CHAR*
  ;

terminal
TOKEN_REF
  :
  'A'..'Z'
  NAME_CHAR*
  ;

/** Allow unicode rule/token names */
terminal
fragment
NAME_CHAR
  :   NAME_START_CHAR
  |   '0'..'9'
  |   '_'
  |   '\u00B7'
  |   '\u0300'..'\u036F'
  |   '\u203F'..'\u2040'
  ;

terminal
fragment
NAME_START_CHAR
  :   'A'..'Z' | 'a'..'z'
  |   '\u00C0'..'\u00D6'
  |   '\u00D8'..'\u00F6'
  |   '\u00F8'..'\u02FF'
  |   '\u0370'..'\u037D'
  |   '\u037F'..'\u1FFF'
  |   '\u200C'..'\u200D'
  |   '\u2070'..'\u218F'
  |   '\u2C00'..'\u2FEF'
  |   '\u3001'..'\uD7FF'
  |   '\uF900'..'\uFDCF'
  |   '\uFDF0'..'\uFFFD'
  ; // ignores | ['\u10000-'\uEFFFF] ;

/** String literal */
@Override 
terminal
STRING
  :
  '\'' LITERAL_CHAR* '\''
  ;

terminal
fragment
LITERAL_CHAR
  :
  ESC
  |
  !(
    '\''
    | '\\'
   )
  ;

terminal
fragment
ESC
  :
  '\\'
  (
    'n'
    | 'r'
    | 't'
    | 'b'
    | 'f'
    | '"'
    | '\''
    | '\\'
    | '>'
    | 'u' XDIGIT XDIGIT XDIGIT XDIGIT
    | . // unknown, leave as it is
  )
  ;

terminal
fragment
XDIGIT
  :
  '0'..'9'
  | 'a'..'f'
  | 'A'..'F'
  ;

/** Language action (a.k.a language code) */
terminal ACTION: NESTED_ACTION;

terminal fragment NESTED_ACTION: '___nested_action_';

terminal
fragment
ACTION_STRING_LITERAL
  :
  '"'
  (
    ACTION_ESC
  |
    !('\\' | '"')
  )*
  '"'
  ;

terminal
fragment
ACTION_CHAR_LITERAL
  :
  '\''
  (
    ACTION_ESC
  |
    !('\\' | '\'')
  )*
  '\''
  ;

terminal
fragment
ACTION_ESC
  : '\\' .
  ;

/** Argument action (a.k.a language code) */
terminal
ARG_OR_CHARSET
  :
    ARG_ACTION
  |
    LEXER_CHAR_SET
  ;

terminal fragment LEXER_CHAR_SET: '___lexer_char_set_';

terminal fragment
ARG_ACTION
  :
   '['
   ( 
//      ARG_ACTION
//   | ACTION_STRING_LITERAL
//   | ACTION_CHAR_LITERAL
//   	| 
   	!('['|']')
  )*
    ']'
  ;

/** Comments */
@Override 
terminal
SL_COMMENT
  :
  '//'
  !(
    '\r'
    | '\n'
   )*
  '\r'? '\n'
  ;

@Override 
terminal
ML_COMMENT
  :
  '/*' -> '*/'
  ;

/** White spaces */
@Override 
terminal
WS
  :
  (
    ' '
    | '\t'
    | '\f'
    | '\r'? '\n'
  )+
  ;

terminal fragment WSNLCHARS: ' ' | '\t' | '\f' | '\n' | '\r';
